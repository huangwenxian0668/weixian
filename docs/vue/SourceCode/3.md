new Vue的过程（vue源码分析3）
---
theme: juejin
highlight: arduino-light
---
> 以下代码和分析过程需要结合vue.js源码查看，通过打断点逐一比对。
**代码**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue.js"></script>
</head>
<body>
    <div id="app">
        <!--this is comment--> {{ message }}
    </div>
    <div id="app1">
        <div>
            <!--count={{count}}-->
            <!--reversedCount={{reversedCount}}-->
        </div>
    </div>

    <script>
        debugger;
        var app = new Vue({
            el: '#app',
            beforeCreate() {},
            created() {},
            beforeMount() {},
            mounted: () => { //挂载元素，获取到DOM节点
                setTimeout(() => {
                    //this.count+=1;
                    //console.log('this.count='+this.count)
                }, 1000)
            },
            beforeUpdate() {},
            updated() {},//挂载元素，获取到DOM节点
            beforeDestroy() {},
            destroyed() {},
            data: function () {
                return {
                    count: 0,
                    message: 'Hello Vue!1111111'
                }
            },
        })
        })
    </script>

</body>

</html>
```
## 1. 在html的js中执行new Vue
> 此时会进入vue.js中的Vue构造函数中
```js
    function Vue(options) {
        // 在vue的webpack版本中这里是：development是process.env.NODE_ENV
        if ("development" !== 'production' && !(this instanceof Vue)
        ) {
            warn('Vue is a constructor and should be called with the `new` keyword');
        }
        this._init(options);
    }
```
options参数如下图所示，它是html中new Vue的入参。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46d586ce44414f81b5ece00354dddff5~tplv-k3u1fbpfcp-watermark.image)

## 2. 执行this._init
**执行了哪些操作：**

1. 初始化 vm.$options（合并选项）
2. 一堆初始化的工作（包括初始化生命周期、事件、渲染函数、data、prop、methods、Computed、watch 等等）
3. mount 生命钩子挂载元素（完整版构建就会有 Compiler 编译过程来生成渲染函数）

```
this._init(options); // 这里入参同上
```


定义的位置：
```js
    var uid$3 = 0;
    //初始化vue
    function initMixin(Vue) {
        Vue.prototype._init = function (options) {
            var vm = this;
            // 递增给每一个组件加一个唯一的uid
            // 【说明1】
            vm._uid = uid$3++;
            
            //开始，结束标签
            var startTag, endTag;
            // 浏览器性能监控
            // 【说明2 config】
            if ("development" !== 'production' && config.performance && mark) {
                startTag = "vue-perf-start:" + (vm._uid);
                endTag = "vue-perf-end:" + (vm._uid);
                mark(startTag);
            }
            // 一个避免被观察到的标志
            vm._isVue = true;
            // merge options 合并选项 参数
            // 【说明3】
            if (options && options._isComponent) { //判断是否是组件
                //优化内部组件实例化
                //因为动态选项合并非常慢，没有一个是内部组件选项需要特殊处理。
                //初始化内部组件
                initInternalComponent(vm, options);
            } else {
                //合并参数 将父值对象和子值对象合并在一起
                //【说明5 mergeOptions】
                vm.$options = mergeOptions(
                    // 解析constructor上的options属性的
                    //【说明4 resolveConstructorOptions】
                    resolveConstructorOptions(vm.constructor), 
                    options || {},
                    vm // 【说明6】
                );
            }
            /* istanbul ignore else */
            {
                //初始化 代理 监听
                // 【说明7】
                initProxy(vm);
            }
            // expose real self 暴露真实的self
            // 执行一系列钩子函数等
            vm._self = vm;
            initLifecycle(vm); //初始化生命周期 标志
            initEvents(vm); //初始化事件
            initRender(vm); // 初始化渲染
            callHook(vm, 'beforeCreate'); //触发beforeCreate钩子函数
            initInjections(vm); // resolve injections before data/props 在数据/道具之前解决注入问题 //初始化 inject
            initState(vm);  //    //初始化状态
            initProvide(vm); // resolve provide after data/props  解决后提供数据/道具  provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性，用于组件之间通信。
            callHook(vm, 'created'); //触发created钩子函数

            /* istanbul ignore if */
            //浏览器 性能监听
            if ("development" !== 'production' && config.performance && mark) {
                vm._name = formatComponentName(vm, false);
                mark(endTag);
                measure(("vue " + (vm._name) + " init"), startTag, endTag);
            }

            // 挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。
            if (vm.$options.el) {
                // $mount在Vue的原型中
                debugger
                vm.$mount(vm.$options.el);
            }
        };
    }
```

我们看一下_init函数定义在哪个地方，往上找我们可以看到`initMixin`方法中有向Vue原型上挂载函数`Vue.prototype._init`，因为是挂载在Vue原型上的，而`this._init(options)`中的this其实也是指代Vue，相当于：`this._init(options)=>Vue._init(options)=>Vue.prototype._init`。

_init我们稍后分析，这里可以执行_init，说明initMixin是先于Vue构造函数之前执行的。往上找就可以看到，在执行new Vue 之前就定义了一些全局变量:
```
    initMixin(Vue);    //初始化vue
    stateMixin(Vue);  //数据绑定，$watch方法
    eventsMixin(Vue);  // 初始化事件绑定方法
    lifecycleMixin(Vue); // 初始化vue 更新 销毁 函数
    renderMixin(Vue); //初始化vue 需要渲染的函数
```
new Vue之前的逻辑我们全部可以查看上一篇文章： **new Vue之前Vue做了哪些操作**，这里就不重复解析了。

ok，现在分析下_init，其实也就是initMixin方法。



**说明1：**

uid$3本身递增了1，但是表达式没有增加，所以vm._uid初始化为0

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81ef6b43007a419fac3db653964b4e7d~tplv-k3u1fbpfcp-watermark.image)
-----------------

**说明2：config**

config也是new Vue之前定义的，一系列配置性的对象：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/077befb436aa4b2198c308db1ca25cb2~tplv-k3u1fbpfcp-watermark.image)

----------------

**说明3：options._isComponent**

我们当前的html文件并没有用到组件。所以这里为false，我们暂时不分析这条线。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10253ea974c8417a82480e5150218fa9~tplv-k3u1fbpfcp-watermark.image)

**说明4：resolveConstructorOptions**

我们当前的html文件并没有用到组件。所以这里为false，我们暂时不分析这条线。
```js
//解析new Vue constructor上的options拓展参数属性的 合并 过滤去重数据
    function resolveConstructorOptions(Ctor) {
        debugger
        var options = Ctor.options;
        // 有super属性，说明Ctor是Vue.extend构建的子类 继承的子类
        if (Ctor.super) { //超类
            var superOptions = resolveConstructorOptions(Ctor.super); //回调超类 表示继承父类
            var cachedSuperOptions = Ctor.superOptions; // Vue构造函数上的options,如directives,filters,....
            if (superOptions !== cachedSuperOptions) { //判断如果 超类的options不等于子类的options 的时候
                // super option changed,
                // need to resolve new options.
                //超级选项改变，
                //需要解决新的选项。
                Ctor.superOptions = superOptions; //让他的超类选项赋值Ctor.superOptions
                // check if there are any late-modified/attached options (#4976) 检查是否有任何后期修改/附加选项(#4976)
                // 解决修改选项 转义数据 合并 数据
                var modifiedOptions = resolveModifiedOptions(Ctor);
                // update base extend options 更新基本扩展选项
                if (modifiedOptions) {
                    //extendOptions合并拓展参数
                    extend(Ctor.extendOptions, modifiedOptions);
                }
                // 优先取Ctor.extendOptions 将两个对象合成一个对象 将父值对象和子值对象合并在一起，并且优先取值子值，如果没有则取子值
                options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
                if (options.name) { //如果参数含有name 组件name

                    options.components[options.name] = Ctor;
                }
            }
        }
        return options //返回参数
    }

```

可以看到，此时`Ctor.options`，有挂载相应的属性，它实际也是在new Vue之前，执行了`initGlobalAPI`挂载的。可以查看上一篇文章： **【new Vue之前Vue做了哪些操作】的第7步**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccca30ec739948d192e0b134092c8adc~tplv-k3u1fbpfcp-watermark.image)

---------------------

**说明5：mergeOptions**，将两个对象合成一个对象 将父值对象和子值对象合并在一起，并且优先取值子值
```js
    function mergeOptions(
        parent, //父值 例：{components: {…}, directives: {…}, filters: {…}, _base: ƒ}
        child, //子值 优选取子值 例：{el: "#app", beforeCreate: ƒ, …}
        vm // Vue实例
    ) {
        debugger
        {
            //检验子组件
            // 说明【5-1】
            checkComponents(child);
        }

        if (typeof child === 'function') {
            //如果child是一个function的话，则把child自己指向child的options属性
            child = child.options;
        }
        // 规范child里面的Props、Inject、Direcitives

        // 格式化属性，确保所有的props的规范都是基于对象的
        // 说明【5-2 normalizeProps】
        normalizeProps(child, vm);

        // 格式化inject
        // 说明【5-3 normalizeInject】
        normalizeInject(child, vm);

        // 格式化指令
        // 说明【5-4 normalizeDirectives】
        normalizeDirectives(child);

        /**
         *看child是否存在extends（存在表示当前组件扩展了另外一个组件），
         递归当前的mergeOptions方法，
         parent就是当前的parent，child就是当前child的extends的值（扩展的那个组件）；
         调用后覆盖parent
         */
        var extendsFrom = child.extends;
        if (extendsFrom) {
            // 递归
            parent = mergeOptions(parent, extendsFrom, vm);
        }

        /**
         * 同上的extends，mixins也可以写data，props等等，因此也可以视为一个组件
         * 所以也需要递归调用
         */
        if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
            }
        }
        
        var options = {};
        var key;
        // parent和child合并字段后组成新的options
        // 通过parent中的key,去取strats对应的方法，然后把值作为options对应key的值
        for (key in parent) { 
            mergeField(key);
        }
        // 同上
        for (key in child) {
            // 只需要处理不在parent中的key
            if (!hasOwn(parent, key)) {
                mergeField(key);
            }
        }


        /**
         * 合并字段
         * 通过key 去读取strats类中的方法
         * strats类 有方法 el，propsData，data，provide，watch，props，
         * methods，inject，computed，components，directives，filters 。
         * 
         */
        function mergeField(key) {
            debugger
            // 说明【5-5 strats】
            var strat = strats[key] || defaultStrat;
            options[key] = strat(parent[key], child[key], vm, key);
        }
        return options
    }
```

**说明5-1：checkComponents**
>验证我们的组件名称符不符合规范。
```js
    function checkComponents(options) {
        for (var key in options.components) {
            // 验证组件名称 必须是大小写，并且是-横杆
            validateComponentName(key);
        }
    }
    
    //验证组件名称 必须是大小写，并且是-横杆
    function validateComponentName(name) {
        if (!/^[a-zA-Z][\w-]*$/.test(name)) {
            warn(
                'Invalid component name: "' + name + '". Component names ' +
                'can only contain alphanumeric characters and the hyphen, ' +
                'and must start with a letter.'
            );
        }
        if (isBuiltInTag(name) || config.isReservedTag(name)) {
            warn(
                'Do not use built-in or reserved HTML elements as component ' +
                'id: ' + name
            );
        }
    }
    
    //检查标记是否为内置标记。
    var isBuiltInTag = makeMap('slot,component', true);
    
    //保留标签 判断是不是 html 原生的标签 或者svg标签
    var isReservedTag = function (tag) {
        return isHTMLTag(tag) || isSVG(tag)
    };
```

**说明5-2 normalizeProps** 

>确保所有props选项语法都规范化为对象格式，检查 props 数据类型，我们知道vue接收props的写法可以是数组的形式，也可以是对象的形式，这个函数就对格式进行处理，确保返回统一的格式
```js
    function normalizeProps(
        options, // 例：child=》{el: "#app", beforeCreate: ƒ, …}
        vm // Vue实例
        ) {
        debugger
        // 如果配置项里面没有props（只有子组件需要和父组件通信才需要写），退出
        var props = options.props;
        if (!props) {
            return
        }
        // 用于保存规范化后的结果
        var res = {};
        var i, val, name;

        /**
         * 数组形式的处理
         * 例： 把子组件接收的props，从props:['myName', 'detail-id']变成:
         * props: {
                myName: {
                    type: null
                },
                detailId: {
                    type: null
                }
            }
         */
        if (Array.isArray(props)) {
            i = props.length;
            while (i--) {
                val = props[i];
                if (typeof val === 'string') {
                    /*
                    把含有'-'的字符串 变成驼峰写法
                    把名称格式为“detail-id”的变为“detailId
                    */
                    name = camelize(val);

                    res[name] = { type: null };
                } else {
                    //props虽然是数组，但是数组项不是字符串的话，会警告你“使用数组语法时，props必须是字符串
                    warn('props must be strings when using array syntax.');
                }
            }
        }
        /**
         * 对象形式的处理
         * 例： props: {
         *          myName: String,
                    portlist: {
                        type: Array,
                        required: true,
                        default: ()=>[]
                    },
                }
            格式化后，变成：
            props: {
                    myName: { type: String },
                    portlist: {
                        type: Array,
                        required: true,
                        default: ()=>[]
                    },
                }
         */
        else if (isPlainObject(props)) { 
            for (var key in props) { 
                val = props[key];
                name = camelize(key);
                res[name] = isPlainObject(val)
                    ? val
                    : { type: val };
            }
        } else {
            //如果不是对象和数组则警告，所以这里也可以看出，props只支持对象和数组
            warn(
                "Invalid value for option \"props\": expected an Array or an Object, " +
                "but got " + (toRawType(props)) + ".",
                vm
            );
        }
        // 这里，就把child里面所有的props给规范化了，最后覆盖了源child的props属性
        options.props = res;
    }
```

**说明5-3 normalizeInject** 

>确保所有inject选项语法都规范化为对象格式，检查 inject 数据类型，我们知道vue接收inject的写法可以是数组的形式，也可以是对象的形式，这个函数就对格式进行处理，确保返回统一的格式

```js
    function normalizeInject(
        options, // 例：child=》{el: "#app", beforeCreate: ƒ, …}
        vm // Vue实例
    ) {
        //  provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。
        /**
         * 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，
         * 不论组件层次有多深，并在起上下游关系成立的时间里始终生效。
         */
        var inject = options.inject;
        if (!inject) {
            return
        }
        // 如果存在inject，需要置空
        // 保存格式化后的inject
        var normalized = options.inject = {};
        /**
         *  数组格式的处理
         */
        if (Array.isArray(inject)) {
            for (var i = 0; i < inject.length; i++) {
                /* 将数组转化成对象 例如inject为：['foo','bar']，转换过程为：
                 * normalized['foo']={from: 'foo'}
                 * normalized['bar']={from: 'bar'}
                   结果：{
                    foo:{from: 'foo'},
                    bar:{from: 'bar'}
                  }
                */
                normalized[inject[i]] = { from: inject[i] };
            }
        }
        /**
         *  对象格式的处理
         */
        else if (isPlainObject(inject)) {
            for (var key in inject) {
                /**如果inject为：
                {
                    foo: {
                        from: 'name1',
                        default: 'name1'
                    },
                    bar
                }
                 * 转换过程为：
                  第一次遍历，key为 foo，val为{from: 'name1',default: 'name1'},是个对象，
                  则执行extend合并{ from: 'foo' }和{from: 'name1',default: 'name1'}
                  结果：
                  {
                     foo: {
                        from: 'name1',
                        default: 'name1'
                    },
                    bar:{from: bar}
                  }
                 */
                var val = inject[key];
                normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
            }
        } else {
            warn(
                "Invalid value for option \"inject\": expected an Array or an Object, " +
                "but got " + (toRawType(inject)) + ".",
                vm
            );
        }
    }

```

**说明5-4 normalizeDirectives** 

>将原始函数指令归一化为对象格式。循环对象指令的值，如果是函数则把`options.directives`变成这种形式:
```
{ 
   getList: { bind: a(), update: a() },
   delete: { bind: b(), update: b() }
}
```
函数
```js
    function normalizeDirectives(
        options // 例：child=》{el: "#app", beforeCreate: ƒ, …}
    ) {
        debugger
        //获取参数中的指令
        var dirs = options.directives;
        if (dirs) { //如果指令存在
            for (var key in dirs) {
                var def = dirs[key];
                if (typeof def === 'function') { //如果是函数
                    //为该函数添加一个对象和值
                    /**例如：options.directives为{ update: a(), delete: b()},转换为
                     { 
                         update: { bind: a(), update: a() },
                         delete: { bind: b(), update: b() }
                     }
                     */
                    dirs[key] = { bind: def, update: def };
                }
            }
        }
    }
```

**说明 5-5. strats**

> strats定义在new Vue之前,可以查看上一篇文章，**【new Vue之前Vue做了哪些操作】**，它可以说了包含了vue所需要的所有东西，如生命周期，data,watch,el等等。


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d78a9d2e00f34ec09f26ab641f24d007~tplv-k3u1fbpfcp-watermark.image)

----------

**说明6：vm**

可以看到这里已经在Vue实例上挂载了相应的属性，它是在new Vue之前，执行了
```
    Object.defineProperty(Vue.prototype, '$isServer', {
        get: isServerRendering
    });
    Vue.prototype.$destroy = function (){}
```
等相关操作挂载的。可以查看上一篇文章： **【new Vue之前Vue做了哪些操作】的第8步**

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/395445b9fc8844aca08f21456b213201~tplv-k3u1fbpfcp-watermark.image)

**说明7 ：initProxy**
```js
        //初始化 代理 监听
        initProxy = function initProxy(vm) {
            debugger
            // 判断 系统内置 函数有没有 es6的Proxy 代理对象api
            if (hasProxy) {
                // determine which proxy handler to use 确定使用哪个代理处理程序
                var options = vm.$options; //获取vm中的参数
                var handlers = options.render && options.render._withStripped
                    ? getHandler  //获取值
                    : hasHandler;  //判断内部函数，这样vue中模板就可以使用内置函数
                //实例化 代理对象，只是这里添加了 警告的日志而已
                vm._renderProxy = new Proxy(vm, handlers);
            } else {
                //如果不能代理直接赋值
                vm._renderProxy = vm;
            }
        };
        
        var hasHandler = {
            has: function has(target, key) {
                var has = key in target;
                //是否含有全局api 就是window 的内置函数
                //全局api
                // var allowedGlobals = makeMap(
                //     'Infinity,undefined,NaN,isFinite,isNaN,' +
                //     'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
                //     'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
                //     'require' // for Webpack/Browserify
                // );

                var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
                //如果  key 在target对象中 不存在 或者 isAllowed 不是全局api 并且 第一个字符不是_的时候 发出警告
                if (!has && !isAllowed) {
                    //不存在key发出警告
                    warnNonPresent(target, key);
                }
                //返回true
                return has || !isAllowed
            }
        };

        var getHandler = {
            get: function get(target, key) {
                //key必须是等于string 并且 key在target中含有属性或者方法
                if (typeof key === 'string' && !(key in target)) {
                    //如果没有则发出警告
                    warnNonPresent(target, key);
                }
                // 返回target值
                return target[key]
            }
        };
```
------------

## 3. $mount
> initMixin执行最后最后一步，会执行$mount，手动挂载

首先缓存了原型上的 $mount 方法，再重新定义该方法，它对 el 做了限制，Vue 不能挂载在 body、html 这样的根节点上。

如果没有render函数，则获取template，template可以是#id、模板字符串、dom元素，如果没有template，则获取el以及其子内容作为模板。 compileToFunctions是对我们最后生成的模板进行解析，生成render函数。

其实vue源码在2个地方定义了`$mount` 方法，分别是文件中间的位置和文件末尾的文字，这里先执行的末尾的位置的 `$mount` 方法。为什么要这样做呢？

末尾的是适用于 Runtime+Compiler 版本的。中间的mount 的 Vue.prototype.$mount 方法是适用于 Runtime Only 版本的。

我们这里先解析末尾的$mount，因为按照我们代码的流程是会先走这里。

**$mount：**
```js
    const mount = Vue.prototype.$mount
    Vue.prototype.$mount = function (
        el,  // 例：#app
        hydrating // 服务端渲染相关，在浏览器环境下我们不需要传
        ) { 
        // 获取dom，已经是dom就返回,不是dom并且获取不到，警告提示，创建一个新的dev
        el = el && query(el); 
        /* istanbul ignore if */
        //如果el 是body 或者文档 则警告
        if (el === document.body || el === document.documentElement) {
            "development" !== 'production' && warn(
                /**
                * 不要将<html>或<body>挂载到vue的mount,而是需要挂载普通元素
                * 因为挂载是覆盖的，如果挂载在body或html上， 覆盖后就没有body和html节点了
                * 所以我们一般采用的都是挂载在div上的形式。
                "Do not mount Vue to <html> or <body> - mount to normal elements instead."
            );
            return this
        }
        //获取参数
        var options = this.$options;
        // resolve template/el and convert to render function
        //解析模板/el并转换为render函数
        if (!options.render) {
            //获取模板字符串
            var template = options.template;
            if (template) { //如果有模板
                if (typeof template === 'string') {
                    //模板第一个字符串为# 则判断该字符串为 dom的id
                    if (template.charAt(0) === '#') {
                        template = idToTemplate(template); //获取字符串模板的innerHtml
                        /* istanbul ignore if */
                        if ("development" !== 'production' && !template) {
                            warn(
                                ("Template element not found or is empty: " + (options.template)),
                                this
                            );
                        }
                    }
                } else if (template.nodeType) { //如果template 是don节点 则获取他的html
                    template = template.innerHTML;
                } else {
                    //如果什么都是不是则发出警告
                    {
                        warn('invalid template option:' + template, this);
                    }
                    return this

                }
            } else if (el) {
                //如果模板没有，dom节点存在则获取dom节点中的html 给模板
                /**  template 例子如下：
                 * "<div id="app">
                        <!--this is comment--> {{ message }}
                    </div>"
                 */
                template = getOuterHTML(el);

            }
            if (template) {
                /* istanbul ignore if */
                //监听性能监测
                if ("development" !== 'production' && config.performance && mark) {
                    mark('compile');
                }
                //创建模板

                
                // 【说明1 compileToFunctions】
                
                var ref = compileToFunctions(
                    template, //模板字符串
                    {
                        shouldDecodeNewlines: shouldDecodeNewlines, //flase //IE在属性值中编码换行，而其他浏览器则不会
                        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref, //true chrome在a[href]中编码内容
                        delimiters: options.delimiters, //改变纯文本插入分隔符。修改指令的书写风格，比如默认是{{mgs}}  delimiters: ['${', '}']之后变成这样 ${mgs}
                        comments: options.comments //当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。
                    },
                    this
                );
                
                //ast 模板
                //code 虚拟dom需要渲染的参数函数
                //staticRenderFns 【说明2 staticRenderFns】

                //这样赋值可以有效地 防止 引用按地址引用，造成数据修改而其他对象也修改问题，
                var render = ref.render;
                var staticRenderFns = ref.staticRenderFns;

                /*
                 render 是  虚拟dom，需要执行的编译函数
                 */
                options.render = render;
                options.staticRenderFns = staticRenderFns;

                /* istanbul ignore if */
                if ("development" !== 'production' && config.performance && mark) {
                    mark('compile end');
                    measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
                }
            }
        }

        // 调用原先原型上的 $mount 方法挂载
        // 再次执行mount，执行的是中间位置定义的$mount
        // 这一步执行完，data就已经渲染到页面了
        return mount.call(
            this, // Vue实例
            el, //真实的dom 例：el = div#app {__vue__: null, align: "", title: "", lang: "", translate: true, …}
            hydrating //undefined
        )
    };
```

**【图1 ref】**


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18a4cf2d493e4c6f8786856830962e65~tplv-k3u1fbpfcp-watermark.image)

**【说明2 staticRenderFns】**

这里的staticRenderFns目前是一个空数组，其实它是用来保存template中，静态内容的render，比如模板为:
```js
<div id="app">
    <p>这是<span>静态内容</span></p>
    <p>{{message}}</p>
</div>
```
staticRenderFns为：
```js
staticRenderFns = function () {
    with(this){return _c('p',[_v("这是"),_c('span',[_v("静态内容")])])
}
```

### 3-1 .编译过程
**说明1：compileToFunctions**, 编译相关函数，为了方便查看，我调整了声明的顺序,并且简化了代码，我们先对调用结构有个了解。这里的函数调用看着有点绕，实际就是做了柯里化，实现了默认传参。

```js

// 【第一步】
// 调用compileToFunctions函数，传进3个参数
// 下一步我们先分析compileToFunctions做了什么操作
var ref = compileToFunctions(
            template,
            {
              shouldDecodeNewlines: shouldDecodeNewlines,
              linesForHref: shouldDecodeNewlinesForHref,
              delimiters: options.delimiters, 
              comments: options.comments
            },
            this
);

// 【第二步】
// 由第一步知道，compileToFunctions是个函数，所以
// ref$1.compileToFunctions返回的也肯定是个函数
// 同时也说明ref$1本身是返回一个对象
var compileToFunctions = ref$1.compileToFunctions;
// 转换为：var ref = ref$1.compileToFunctions(template,{...},this)
    
// 【第三步】
// 说明 createCompiler函数返回的是一个对象
// 入参baseOptions是在new Vue之前定义的
var ref$1 = createCompiler(baseOptions);
// 继续转换为：var ref = createCompiler(baseOptions).compileToFunctions(template,{...},this)

// 【第四步】
// 由第三步，可以知道，createCompilerCreator函数返回的也是一个对象
var createCompiler = createCompilerCreator(
     function baseCompile(template,options) {
            return {
                ast: ast, //ast 模板
                render: code.render, //code 虚拟dom需要渲染的参数函数
                staticRenderFns: code.staticRenderFns  //空数组
            }
     });
}
/**
*继续转换为：
var ref = createCompilerCreator(function baseCompile(){template,options})
(baseOptions).compileToFunctions(template,{...},this)
现在终于调用到了createCompilerCreator函数，我们接着看createCompilerCreator返回了什么
*/

// compile函数返回了compiled，compiled又是由入参函数baseCompile返回的，
// 即前面的createCompiler 里面的参数函数function baseCompile(template,options) {});
// 返回一个函数，该函数又返回了一个封装对象:{  ast: ast, render...,staticRenderFns:... },
// 即compile函数也返回了这个对象
function createCompilerCreator(
            baseCompile 
        ) {
            return function createCompiler(baseOptions) {
               function compile(template,options) {
                    var compiled = baseCompile(
                        template,
                        finalOptions
                    );
                    return compiled
                }
                return {
                    compile: compile,
                    compileToFunctions: createCompileToFunctionFn(compile)
                }
           }
}

// 由上一步可知，compile是个函数，并且返回一个对象 
/**
* createCompilerCreator(function baseCompile(){template,options})
  (baseOptions).compileToFunctions其实就是取createCompilerCreator返回的对象的compileToFunctions
  属性，即createCompileToFunctionFn(compile)的值
  所以，可以再次转换：
* var ref = createCompileToFunctionFn(function baseCompile(){template,options})
            (baseOptions).compileToFunctions(template,{...},this)
            
* 没看错，这就是我们终极转换的函数执行链，现在就很清晰了，createCompileToFunctionFn函数的入参compile
* 就是function baseCompile(){template,options}，
* compileToFunctions的入参就是上面compileToFunctions函数的参数(template,{...},this)，即第一步的入参
*/
function createCompileToFunctionFn(compile) {
        return function compileToFunctions(
            template,
            options,
            vm 
        ) {
            var compiled = compile(
                template,
                options
            );
            return (cache[key] = res)
        }
}

```
现在可以仔细分析了：


来看下函数是`createCompilerCreator`怎么定义的,这里的`baseCompile`就是上面`createCompilerCreator`函数的入参：`baseCompile`,里面的`baseOptions`（new Vue之前定义的）也是从前面的函数传递过来的。最终所有的逻辑都会走到这个函数，前面的逻辑可以认为是提供函数参数的操作。
```js
    // 最终返回compile函数
        function createCompilerCreator(
            baseCompile // 基本的编译函数，传入这个参数是为了让我们在当前函数
                        // 能调用传入函数，同时给他传参
        ) {
            return function createCompiler(baseOptions) { //[图1]
                debugger
                function compile(
                    template, // 例："<div id="app">{{ message }} </div>" [图2]
                    options   // 例：{shouldDecodeNewlines: false...} [图3]
                ) {
                    debugger
                    // 创建一个对象 拷贝baseOptions 拷贝到 原型 protype 中
                    // [图4]
                    var finalOptions = Object.create(baseOptions); //为虚拟dom添加基本需要的属性
                    var errors = [];
                    var tips = [];
                    // 警告函数
                    finalOptions.warn = function (msg, tip) {
                        (tip ? tips : errors).push(msg);
                    };

                    if (options) {
                        // 合并modules到finalOptions
                        if (options.modules) { 
                            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
                        }
                        // 合并指令到finalOptions
                        if (options.directives) {
                            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
                        }

                        // 复制其他选项到finalOptions
                        for (var key in options) {
                            if (key !== 'modules' && key !== 'directives') {
                                //浅拷贝
                                finalOptions[key] = options[key];
                            }
                        }
                    }
                    /**
                     * 这2个参数会作为参树传入到：createCompiler = 
                     * createCompilerCreator(function baseCompile(template, options) {})中的
                     * template, options中
                     */
                    //【图4  compiled】
                    var compiled = baseCompile(
                        template, 
                        finalOptions // 为虚拟dom添加基本需要的属性
                    );


                    {
                        errors.push.apply(errors, detectErrors(compiled.ast));
                    }
                    compiled.errors = errors;
                    compiled.tips = tips;
                    return compiled
                }

                /*
                * compile
                *在 render 函数中编译模板字符串。只在独立构建时有效
                var res = Vue.compile('<div><span>{{ msg }}</span></div>')
                new Vue({
                data: {
                    msg: 'hello'
                },
                    render: res.render,
                    staticRenderFns: res.staticRenderFns
                })
                *
                *
                *
                * */
               debugger
                return {
                    compile: compile,
                    compileToFunctions: createCompileToFunctionFn(compile)
                }
            }
        }
```

**[图1] baseOptions:**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b20efb007a346169fc6df9aa494c338~tplv-k3u1fbpfcp-watermark.image)

**[图2] template:**

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/819ceb44ec994cdd809e2c1fbcfe916e~tplv-k3u1fbpfcp-watermark.image)

**[图3] options:**

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d5a17134c7408e9e69904c8a02ccf7~tplv-k3u1fbpfcp-watermark.image)

**[图4] finalOptions:**

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f61dc1467b94c6586a0ebd496bc8f84~tplv-k3u1fbpfcp-watermark.image)

**说明1 baseCompile**

> baseCompile函数是回调时才触发的。
```js
    //编译器创建的创造者
        var createCompiler = createCompilerCreator(

        //把html变成ast模板对象，然后再转换成 虚拟dom 渲染的函数参数形式。
        // 返回出去一个对象
        // {ast: ast, //ast 模板
        // render: code.render, //code 虚拟dom需要渲染的参数函数
        //staticRenderFns: code.staticRenderFns } //空数组

        function baseCompile(
            template, // "<div id=\"app\">\n <!--this is comment--> {{ message }}\n </div>"
            options // 这里已经baseOptions和options的合并项了 【图1 】
        ) {
            
            //返回ast模板对象 
            // parse函数非常关键，我们将在下一节解析
            // 【图2 ast】
            var ast = parse(template.trim(), options);
            // optimize 的主要作用是标记 static 静态节点
            // optimize 也将在后面的章节解析
            if (options.optimize !== false) {  
                // * 循环递归虚拟node，标记是不是静态节点
                //*  根据node.static或者 node.once 标记staticRoot的状态
                // 我们将在下一节解析
                optimize(ast, options);
            }
            //初始化扩展指令，on,bind，cloak,方法， dataGenFns 获取到一个数组，
            // 数组中有两个函数genData和genData$1
            //genElement根据el判断是否是组件，或者是否含有v-once，v-if,v-for,是否有template属性，
            // 或者是slot插槽，转换style，css等转换成虚拟dom需要渲染的参数函数
            //返回对象{ render: ("with(this){return " + code + "}"),staticRenderFns: state.staticRenderFns} //空数组
            // 我们将在下一节解析
            // 【图3 code】
            var code = generate(ast, options);

            return {
                ast: ast, //ast 模板
                render: code.render, //code 虚拟dom需要渲染的参数函数
                staticRenderFns: code.staticRenderFns  // 静态渲染函数，数组
            }
     });
```

**【图1 options】**


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae528be0a06a42e7ac8555b1a02166b7~tplv-k3u1fbpfcp-watermark.image)

**【图2 ast】**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1546812389474e53bc2aa23d0eaa3fa7~tplv-k3u1fbpfcp-watermark.image)

**【图3 code】**

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a67551f15084dd29edb7a4682c5e37e~tplv-k3u1fbpfcp-watermark.image)

**【图4  compiled】**

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/047efe30ab4343eba98bf5830d31bb73~tplv-k3u1fbpfcp-watermark.image)

---------------------------

**createCompilerCreator最后面就是执行createCompileToFunctionFn**
```js
       function createCompileToFunctionFn(compile) {
        
        var cache = Object.create(null);
        /**
         * 这里又返回了一个函数，父函数作为属性值在createCompilerCreator中：
         * {
                compile: compile,
                compileToFunctions: createCompileToFunctionFn(compile)
            }

         * 所以createCompileToFunctionFn(compile)可以看作是执行了当前的返回函数：
            compileToFunctions(template, options, vm )
        //  * 我们往前推，可以看到上面那个对象的compileToFunctions属性是在mount的ref中
        //     调用的，因此，compileToFunctions的入参就是定义ref时传入的
        //  * 
        */
            
        return function compileToFunctions(
            // 这几个入参就是compileToFunctions: createCompileToFunctionFn(compile)中
            // 的compile返回的三个参数
            template,  //  "<div id=\"app\">
            options,  // {shouldDecodeNewlines: false,...}
            vm  // Vue实例
        ) {
            
            //浅拷贝参数
            options = extend({}, options);
            //警告
            var warn$$1 = options.warn || warn;
            //删除参数中的警告
            delete options.warn;

            /*
             *这个选项只在完整构建版本中的浏览器内编译时可用。
             * 详细：改变纯文本插入分隔符。
             *
             * 示例：
             new Vue({
                delimiters: ['${', '}']
             })
             // ['${', '}'] String后变成了 "${,}"
             */

            var key = options.delimiters ? String(options.delimiters) + template : template;
            if (cache[key]) {
                return cache[key]
            }
            
            // compile 传进来的函数, 返回值就是baseCompile函数返回值
            var compiled = compile(
                template, //模板字符串
                options //参数
            );

            // turn code into functions 将代码转换为函数
            var res = {};
            var fnGenErrors = [];
            //将compiled.render创建一个函数，如果发生错误则记录fnGenErrors错误
            //把字符串 转化成真正的js并且以 函数的方式导出去
            // 【说明1 createFunction】
            // 【图1 res】
            res.render = createFunction(
                compiled.render,
                fnGenErrors);
            
            res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
                return createFunction(code, fnGenErrors)
            });
            
            // 【图2 3】
            return (cache[key] = res)
        }
    }
```

**【说明1 createFunction】**,把字符串 转成真正的js 并且以一个函数形式导出去
```js
    function createFunction(
        code, // 例："with(this){return _c('div',{attrs:{"id":"app"}},[_v(" "+_s(message)+"\n    ")])}"
        errors
        ) {
        debugger
        try {
            return new Function(code)
            /**
             * 转换成函数：
             * (function anonymous() {
                with(this){return _c('div',{attrs:{"id":"app"}},[_v(" "+_s(message)+"\n    ")])}
                })
             */
        } catch (err) {
            errors.push({ err: err, code: code });
            return noop
        }
    }
```
**【图1 res.render**,可以看到res.render已经是个函数了

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eec0aced10d84514bf89b08ea7bc9b40~tplv-k3u1fbpfcp-watermark.image)

**【图2】cache**，以template为key的对象

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec8ef4b3454c4b4993f0db2e970c52c3~tplv-k3u1fbpfcp-watermark.image)

**【图3】res**，渲染函数对象

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e83a8de28c34c3c905de9d074f9cd9d~tplv-k3u1fbpfcp-watermark.image)

到这里，整个编译的过程就解析完成了。


### 3-2 后续

最终我们的**ref**是这样的：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89bb5324013648df9026f9b2c3619d3f~tplv-k3u1fbpfcp-watermark.image)

然后挂载ref上的属性到options上：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3b3da7487a5483d9d17feb24a645099~tplv-k3u1fbpfcp-watermark.image)

### 3-3 第二次执行mount

当我们在末尾的mount执行：
```js
return mount.call(
       this, // Vue实例
       el, //真实的dom 例：el = div#app {__vue__: null, align: "", title: "", lang: "", translate: true, …}
       hydrating //undefined
)
```

它会继续执行mount，不过此时的mount是中间定义的mount,如下：

```js
    Vue.prototype.$mount = function (
        el, 
        hydrating
        ) {
        // query(el) 获取dom，已经是dom就返回,不是dom并且获取不到，警告提示，创建一个新的dev
        el = el && inBrowser ? query(el) : undefined;
        return mountComponent(
            this, // Vue实例
            el,  // 真实dom 例：el = div#app {align: "", title: "", lang: "", translate: true, dir: "", …}
            hydrating
        )
    };
```
**mountComponent:**
> 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法。这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 template 属性，最终都会转换成 render 方法，那么这个过程是 Vue 的一个“在线编译”的过程

mountComponent 核心就是先调用 vm._render 方法,先生成虚拟 Node，再实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法，最终调用 vm._update 更新 DOM。

  
```js
    //安装组件
    function mountComponent(
        vm,  //Vue 实例
        el,  //真实dom
        hydrating //新的虚拟dom vonde
    ) {
        debugger
        // 将真实dom挂载到vue实例上去
        vm.$el = el;
        /*
        Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，
        前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，
        需要借助 webpack 的 vue-loader 事先把模板编译成 render函数。
         */

        //如果参数中没有渲染函数，说明使用的是 Runtime only
        if (!vm.$options.render) { //实例化vm的渲染函数，虚拟dom调用参数的渲染函数
            //创建一个空的组件
            vm.$options.render = createEmptyVNode;

            {
                /* istanbul ignore if */
                //如果参数中的模板第一个不为# 号则会 警告，因为Runtime only版本的代码是这种格式：el: '#app',
                if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
                    vm.$options.el || el) {
                    /*
                        您使用的是 Runtime only 生成的Vue，其中模板编译器不可用。
                        或者将模板预编译为渲染函数，或使用内置的编译器。
                    */
                    warn(
                        'You are using the runtime-only build of Vue where the template ' +
                        'compiler is not available. Either pre-compile the templates into ' +
                        'render functions, or use the compiler-included build.',
                        vm
                    );
                } else {
                    // 无法装载组件：未定义template或render函数
                    warn(
                        'Failed to mount component: template or render function not defined.',
                        vm
                    );
                }
            }
        }

        //执行生命周期函数 beforeMount
        callHook(vm, 'beforeMount');
        //更新组件
        var updateComponent;
        /* istanbul ignore if */
        //如果开发环境
        /*
            Vue.config.performance为true的话，以在浏览器开发工具的性能/时间线面板中
            启用对组件初始化、编译、渲染和打补丁的性能追踪
        */
        
        if ("development" !== 'production' && config.performance && mark) {
            updateComponent = function () {
                var name = vm._name;
                var id = vm._uid;
                var startTag = "vue-perf-start:" + id;
                var endTag = "vue-perf-end:" + id;

                mark(startTag); //插入一个名称 并且记录插入名称的时间
                var vnode = vm._render();
                mark(endTag);
                measure(("vue " + name + " render"), startTag, endTag);

                mark(startTag); //浏览器 性能时间戳监听
                //更新组件
                vm._update(vnode, hydrating);
                mark(endTag);
                measure(("vue " + name + " patch"), startTag, endTag);
            };
        } else {
            updateComponent = function () {
                //直接更新view试图
                // 【在第一篇 new Vue有讲解】
                vm._update(
                    /*
                     render 是  虚拟dom，需要执行的编译函数 类似于这样的函数
                     (function anonymous( ) {
                     with(this){return _c('div',{attrs:{"id":"app"}},[_c('input',{directives:
                        [{name:"info",rawName:"v-info"},{name:"data",rawName:"v-data"}],
                        attrs:{"type":"text"}}),_v(" "),_m(0)])}
                     })
                     */
                    vm._render(), //先执行_render,返回虚拟 Node
                    hydrating
                );
            };
        }

        // we set this to vm._watcher inside the watcher's constructor
        // since the watcher's initial patch may call $forceUpdate (e.g. inside child
        // component's mounted hook), which relies on vm._watcher being already defined
        //我们将其设置为vm。在观察者的构造函数中
        //因为观察者的初始补丁可能调用$forceUpdate(例如inside child)
        //组件的挂载钩子)，它依赖于vm。_watcher已经定义
        //创建观察者
        new Watcher(
            vm,  //vm vode
            updateComponent, //数据绑定完之后回调该函数。更新组件函数 更新 view试图
            noop, //回调函数
            null, //参数
            true //是否渲染过得观察者
            /* isRenderWatcher */
        );
        hydrating = false;

        // manually mounted instance, call mounted on self
        // mounted is called for render-created child components in its inserted hook
        //手动挂载实例，调用挂载在self上
        // 在插入的钩子中为呈现器创建的子组件调用// mount
        if (vm.$vnode == null) {
            vm._isMounted = true;
            //执行生命周期函数mounted
            // 渲染data
            callHook(vm, 'mounted');
        }
        debugger
        return vm
    }
```



## 5. optimize
optimize，标注静态节点。

## 6. generate
generate，生成render表达式。
